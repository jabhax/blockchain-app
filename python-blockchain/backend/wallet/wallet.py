import json
import uuid

from backend.config import STARTING_BALANCE
from backend.util.crypto_hash import utf8
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import hashes as hs
from cryptography.exceptions import InvalidSignature


class Wallet:
    '''
        An individual wallet for a miner that keeps track of their balance
        and allows a miner to authorize transactions.
    '''

    def __init__(self):
        '''
         *** Wallet Class Properties ***
        private_key: The private key of a wallet must be kept secret. It is
                     used to generate signatures on behalf of the wallet owner
                     for based on objects of data. For example, a wallet owner
                     will sign a generated transaction to make it official.

        public_key:  The public key is the other half of the keypair, and it
                     can be publicly shared with other entities.

        signature:   A signatures is a unique data object created using the
                     private key of keypair and an original data object to
                     sign. With the signature, public key, and the original
                     data object, other entities can verify if the signature
                     was generated by the true owner of the public key.

        *** Algorithms ***
        ECDSA:       Elliptic Cryptography Digital Signature Algorithm, and it
                     is the underlying implementation of the cryptography
                     python module used in the project. The mathematics behind
                     the system uses elliptic curves to create keypairs and
                     signatures.
        SECP256K1:   Stands for Standard of Efficient Cryptograpy Prime
                     256-Bits Koblitz-1 as in the first implementation of the
                     algorithm which represents 256 Binary Bits.
        '''
        self.address = str(uuid.uuid4())[0:8]
        self.balance = STARTING_BALANCE
        self.private_key = ec.generate_private_key(
            ec.SECP256K1(), default_backend())
        self.public_key = self.private_key.public_key()

    def sign(self, data):
        '''
            Generate a signature based on data using local private
            key.
        '''
        # Sign the data using private key and ECDSA:
        # Elliptic Cryptography Digital Signature Algorithm
        # Use primitives module with SHA256 
        return self.private_key.sign(utf8(json.dumps(data)), ec.ECDSA(hs.SHA256()))

    @staticmethod
    def verify(public_key, data, signature):
        '''
            Verify a signature based on the original public key and data.
        '''
        try:
            public_key.verify(signature, utf8(json.dumps(data)), ec.ECDSA(hs.SHA256()))
            return True
        except InvalidSignature:
            return False


def main():
    wallet = Wallet()
    print(f'wallet.__dict__: {wallet.__dict__}')
    data = {'foo': 'bar'}
    signature = wallet.sign(data)
    print(f'Signature: {signature}')
    should_be_valid = Wallet.verify(wallet.public_key, data, signature)
    print(f'should_be_valid: {should_be_valid}')
    should_be_invalid = Wallet.verify(Wallet().public_key, data, signature)
    print(f'should_be_invalid: {should_be_invalid}')


if __name__ == '__main__':
    main()
