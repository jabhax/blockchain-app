import json
import uuid

from backend.config import STARTING_BALANCE
from backend.util.crypto_hash import utf8
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives.asymmetric.utils import (
    encode_dss_signature, decode_dss_signature)
from cryptography.hazmat.primitives import hashes as hs, serialization
from cryptography.exceptions import InvalidSignature


class Wallet:
    '''
        An individual wallet for a miner that keeps track of their balance
        and allows a miner to authorize transactions.
    '''

    def __init__(self, blockchain=None):
        '''
         *** Wallet Class Properties ***
        private_key: The private key of a wallet must be kept secret. It is
                     used to generate signatures on behalf of the wallet owner
                     for based on objects of data. For example, a wallet owner
                     will sign a generated transaction to make it official.

        public_key:  The public key is the other half of the keypair, and it
                     can be publicly shared with other entities.

        signature:   A signatures is a unique data object created using the
                     private key of keypair and an original data object to
                     sign. With the signature, public key, and the original
                     data object, other entities can verify if the signature
                     was generated by the true owner of the public key.

        *** Algorithms ***
        ECDSA:       Elliptic Cryptography Digital Signature Algorithm, and it
                     is the underlying implementation of the cryptography
                     python module used in the project. The mathematics behind
                     the system uses elliptic curves to create keypairs and
                     signatures.
        SECP256K1:   Stands for Standard of Efficient Cryptograpy Prime
                     256-Bits Koblitz-1 as in the first implementation of the
                     algorithm which represents 256 Binary Bits.
        '''
        self.blockchain = blockchain
        self.address = str(uuid.uuid4())[0:8]
        self.private_key = ec.generate_private_key(
            ec.SECP256K1(), default_backend())
        self.public_key = self.private_key.public_key()
        self.serialize_public_key()

    @property
    def balance(self):
        return Wallet.calculate_balance(self.blockchain, self.address)

    def sign(self, data):
        '''
            Generate a signature based on data using local private
            key.
        '''
        # Sign the data using private key and ECDSA:
        # Elliptic Cryptography Digital Signature Algorithm
        # Use primitives module with SHA256 
        return decode_dss_signature(self.private_key.sign(
            utf8(json.dumps(data)), ec.ECDSA(hs.SHA256())))

    def serialize_public_key(self):
        '''
            Reset the public key to its serialized version.

            - Use PEM file for serialization encoding.
              PEM Format as follows:
                ---- BEGIN
                kajsdnakjsdnasn_some_text_sahjdnakjdsak...
                ---- END
            - Use PublicFormat.SubjectPublicKeyInfo as it is the default option
              for the Public Bytes algorithm. Which can represent the
              bytestring in several ways depending on application needs.
        '''
        self.public_key = self.public_key.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo
        ).decode('utf-8')

    @staticmethod
    def verify(public_key, data, signature):
        '''
            Verify a signature based on the original public key and data.
        '''
        deserialized_public_key = serialization.load_pem_public_key(
            utf8(public_key), default_backend())
        (r, s) = signature
        try:
            deserialized_public_key.verify(
               encode_dss_signature(r, s), utf8(json.dumps(data)), ec.ECDSA(hs.SHA256()))
            return True
        except InvalidSignature:
            return False

    @staticmethod
    def calculate_balance(blockchain, address):
        '''
            Calculate the balance of the given address considering the
            transaction data within the blockchain.

            The balance is found by adding the output values that belong to
            the address since the most recent transaction by that address.
        '''
        balance = STARTING_BALANCE
        if not blockchain:
            return balance

        for block in blockchain.chain:
            for trans in block.data:
                if trans['input']['address'] == address:
                    # Any time the address conducts a new transaction, it
                    # resets its balance.
                    balance = trans['output'][address]
                elif address in trans['output']:
                    # This is a check if the recipient of the transaction is the
                    # address.
                    balance += trans['output'][address]
        return balance


def main():
    wallet = Wallet()
    print(f'wallet.__dict__: {wallet.__dict__}')
    data = {'foo': 'bar'}
    signature = wallet.sign(data)
    print(f'Signature: {signature}')
    should_be_valid = Wallet.verify(wallet.public_key, data, signature)
    print(f'should_be_valid: {should_be_valid}')
    should_be_invalid = Wallet.verify(Wallet().public_key, data, signature)
    print(f'should_be_invalid: {should_be_invalid}')


if __name__ == '__main__':
    main()
